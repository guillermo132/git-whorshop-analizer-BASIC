
package PECL1;

import java_cup.runtime.*;
import java.io.*;

parser code
{:
	public static void main (String argc[]) throws Exception{
	   String extension="";
	   String programa=argc[0]; 
	   
	   for (int i=programa.length()-4;i<programa.length();i++){
	   		extension=extension+programa.charAt(i);
	   }
	  if(extension.equals(".bas")){
	     	FileInputStream basic =new FileInputStream(programa);
	     	Analizador_LexicoLex y=new Analizador_LexicoLex(basic);
	   		Analizador_SintacticoCup principal=new Analizador_SintacticoCup(y);
	   		principal.parse();
	   		System.out.println("ANALIZADOR LEXICO");
	   		y.writeOutputFile();
	   		System.out.println("\nNumero de errorres lexicos: "+ y.getErr()+"\n");
	   		
	  }
	  else{
	  	System.err.println("ERROR. EL ARCHIVO DEBE DE SER .bas");
	  }
	}  
	public void syntax_error(Symbol s) {
	  System.err.println("Error de sintaxis linea " +(s.left+1)+" en o cerca de "+s.value);
	 
	 
	}  
	public void report_fatal_error(String message, Object info) {
	  done_parsing();
	  report_error("Error de sintaxis fatal : "
	  + "No se puede recuperar del error y continuar con el analisis - "
	  + message + " ",(Symbol)info);
	  report_error("** Final del analisis.", null);
	  System.exit(1);
}
  
:}

action code
{:
	int numErr=0;
	int numErrS=0;
:}
terminal		DATA, DEF, DIM, END, FOR, GO, GOSUB, GOTO, IF, INPUT, LET, NEXT, ON, PRINT, RND, READ, 
				REM, RESTORE, RETURN, STEP, STOP, THEN, TO, IGUAL, MAS, MENOS, MUL, IDE, IDE_NUM, DIVISION, 
				POTENCIA, CRLF, CR, LF, PUNTOYCOMA, FUNCION_MAT, PARENTESIS_IZQ, PARENTESIS_DER, ID, 
				RANDOMIZE, FUNCION, EXPONENTE;
				
terminal String CONSTANTE;

terminal     	ENTERO, CONSTANTE_NUM;

non terminal	inicio, programa, leerLinea, expresion, operacion, operador, operadorParent, opcion2, operando, opcion;
non terminal	operaciones;

precedence right MAS, MENOS;
precedence right MUL, DIVISION,EXPONENTE;

//Gramatica 
start with inicio;

inicio          ::= programa | programa inicio;

programa		::= ENTERO:e leerLinea
							{: 
								System.out.println(e.toString());
							:};
							
leerLinea		::=  DEF expresion
					|INPUT CONSTANTE PUNTOYCOMA IDE CRLF{:
														System.out.println("INPUT");
													:};
expresion		::= FUNCION IGUAL operacion{:/* a�adeExpresion();*/:};

operacion       ::= opcion:o {:  :}
					| error opcion ;

opcion          ::= operaciones {: :}
					| PARENTESIS_IZQ operaciones PARENTESIS_DER {: :};

operaciones     ::= operador:o operando:op operadorParent:opa opcion2:o2 {:String s=o+""+op+""+opa+""+o2; RESULT=s;:}
					| operando:o1 operador:o operando:o2 operadorParent:opa opcion2:op2 {:String s=o1+""+o+""+o2+""+opa+""+o2; RESULT=s;:}
					| error{:numErr++;:};

opcion2         ::= opcion:o {:RESULT=o;:} | {:RESULT="";:} ;

operando        ::= CONSTANTE_NUM:id {:/*compruebaInt(id, idleft+1);*/ RESULT=id.toString();:}
					| IDE_NUM:id {:/*compruebaInt(id, idleft+1);*/ RESULT=id.toString();:}; 

operadorParent  ::= operador:o {:RESULT=o;:}
					 | {:RESULT="";:};
					 
operador        ::= MAS {:RESULT="+";:}
					| MENOS {:RESULT="-";:}
					| DIVISION {:RESULT="/";:}
					| MUL {:RESULT="*";:}
					| EXPONENTE {:RESULT="^";:};
				   
/* 
					 DATA {::} 
					| DEF {::} 
					| DIM {::} 
					| FOR {::} 
					| GO {::} 
					| GOSUB {::} 
					| GOTO {::} 
					| IF {::} 
					| 
					| LET {::} 
					| NEXT {::} 
					| ON {::} 
					| PRINT {::}
					| RND {::}
					| READ {::}
					| REM {::}
					| RESTORE {::}
					| RETURN {::}
					| STEP {::}
					| STOP {::}
					| THEN {::}
					| TO {::}
					| IDE {::}
					| CONSTANTE:e {:System.out.println(e.toString());:}
					| CRLF {::}
					| CR {::}
					| LF {::}
					| PUNTOYCOMA {::}
					| CONSTANTE_NUM {::}
					| ID {::}
					;
					*/
					

/*
terminal String		DATA, DEF, DIM, END, FOR, GO, GOSUB, GOTO, IF, INPUT, LET, NEXT, ON, PRINT, RANDOMIZE, READ, 
					REM, RESTORE, RETURN, STEP, STOP, THEN, TO, IGUAL, MAS, MENOS, MUL, IDE, DIVISION, POTENCIA,
					CONSTANTE, CRLF, CR, LF, PUNTOYCOMA, ENTERO;
terminal String	 	ID;

non terminal	inicio, programa, variables, variable, var, expresion, enum, sentencias, asignacion, tipo, tipoBool, comp, comparacion, mas, otra;
non terminal    logica, exLogicas, tLogica, if, for, operacion, operaciones, operando, operador, conSigno, numero, parentExLogica, operadorParent;
non terminal    skip, write, read, opcion, opcion2, expresion2, nombreProg;

precedence right OR;
precedence right AND;
precedence right NOT;
precedence right MENOR_IGUAL, MENOR, IGUAL, MAYOR, MAYOR_IGUAL, DISTINTO;
precedence right MAS, MENOS;
precedence right DIVISION, MUL;

//gramatica
start with inicio;
inicio          ::=ENTERO sentencia programa {: fin(); :};
nombreProg      ::=IDE:NOMBRE		{: tSimbolos.put(NOMBRE.toString(), new Simbolo("pseudo")); raiz = new NodoRaiz();  a= new Arbol(raiz);:}		;										

variables       ::=variables variable  
					{:
						aux1=new NodoIntermedio("Decl"); aux1.añadirHijo(aux); raiz.añadirHijo(aux1); 
					:}
				| ; 
variable        ::=VAR enum DOS_PUNTOS var:variable PUNTO_COMA 
					{:
						aux = new NodoIntermedio(variable.toString());  añadeHojaDecl();  añadirVariables(variable, variableleft+1);
					:}
				 | VAR:e enum PUNTO_COMA  
				 	{:
				 		aux = new NodoIntermedio("undefined"); añadeHojaDecl(); añadirVariablesUnd(eleft+1);  
				 	:}
				 | error 
				 	{:
				 		numErr++;
				 	:};*/
				 	